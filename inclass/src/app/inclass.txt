

  //good for having an order to dependent statements
  //like a large if else tree

  let p = new Promise(
    (resolve, reject) => {
      //resolve and reject are both functions
      //they are the outcomes when you perform your task. If successful, call resolve else reject
      //sleep timer
      setTimeout(() => {
        console.info('COMPLETED')
        resolve('task is successful') //cannot un resolve and resolved task
        reject('task has failed')
      }, 5000)
    })

    //resolve calls this function on success
    p
    .then(result =>{
      console.info('>>> promise resolved: ', result)
      return 'this is another reults' //whatever you return in then block becomes a promise
    })
    .then(result =>{
      console.info('second promise: ', result)
        //throw 'this is an error from the 2nd promise'
          //jumps straight to catch block, if there nos catch block node.js handles it with its own exception

      return 123
    }).then(result =>{
      console.info('third promise value: ', result)
    })
    .catch(error =>{console.info('>>> promise has failed: ', error)})

    console.info('>>> p =', p)
